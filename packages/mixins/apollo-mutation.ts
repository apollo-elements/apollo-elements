import type { DocumentNode } from 'graphql/language/ast';
import type { ApolloError, ErrorPolicy } from 'apollo-client';
import type { MutationOptions, MutationUpdaterFn } from 'apollo-client/core/watchQueryOptions';
import type { ApolloElement } from './apollo-element';
import type { FetchResult } from 'apollo-link';

export declare class ApolloMutation<TData, TVariables> extends ApolloElement<TData> {
  declare data: TData;

  declare error: Error|ApolloError;

  declare errorPolicy: ErrorPolicy;

  /**
   * An object that maps from the name of a variable as used in the mutation GraphQL document to that variable's value.
   */
  declare variables: TVariables;

  /** The mutation. */
  declare mutation: DocumentNode;


  /**
   * An object that represents the result of this mutation that
   * will be optimistically stored before the server has actually returned a
   * result.
   *
   * This is most often used for optimistic UI, where we want to be able to see
   * the result of a mutation immediately, and update the UI later if any errors
   * appear.
   */
  declare optimisticResponse?: MutationOptions['optimisticResponse'];

  /**
   * Callback for when a mutation is completed.
   */
  onCompleted?(_data: FetchResult<TData>): void

  /**
   * Callback for when an error occurs in mutation.
   */
  onError?(_error: Error): void

  declare loading: boolean;

  declare called: boolean;

  declare ignoreResults: boolean;

  declare mostRecentMutationId: number;

  /**
   * A function which updates the apollo cache when the query responds.
   * This function will be called twice over the lifecycle of a mutation.
   * Once at the very beginning if an optimisticResponse was provided.
   * The writes created from the optimistic data will be rolled back before
   * the second time this function is called which is when the mutation has
   * succesfully resolved. At that point update will be called with the actual
   * mutation result and those writes will not be rolled back.
   *
   * The reason a DataProxy is provided instead of the user calling the methods
   * directly on ApolloClient is that all of the writes are batched together at
   * the end of the update, and it allows for writes generated by optimistic
   * data to be rolled back.
   */
  updater?(...params: Parameters<MutationUpdaterFn<TVariables>>):
    ReturnType<MutationUpdaterFn<TVariables>>;

  public mutate(
    params?: Partial<MutationOptions<unknown, TVariables>>
  ): Promise<FetchResult<TData>>;
}
