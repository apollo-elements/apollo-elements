import type { DocumentNode } from 'graphql/language/ast';
import type { Constructor } from './constructor';
import type { MutationOptions, MutationUpdaterFn } from 'apollo-client';

import { FetchResult } from 'apollo-link';
import { ApolloError } from 'apollo-client';

import bound from 'bind-decorator';

import { ApolloElementMixin } from './apollo-element-mixin';
import { dedupeMixin } from '@open-wc/dedupe-mixin';

type PickMutateOptionsFn =
  <OperationVariables>(o: Partial<MutationOptions<OperationVariables>>) =>
    MutationOptions<OperationVariables>;

// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
function ApolloMutationMixinImplementation<
  TBase extends Constructor<HTMLElement>
>(superclass: TBase) {
  /**
   * Class mixin for apollo-mutation elements
   */
  class ApolloMutationElement<
    TData,
    TVariables,
  > extends ApolloElementMixin(superclass)<TData> {
    /** The mutation. */
    get mutation(): DocumentNode { return this.document; }

    set mutation(mutation) {
      try {
        this.document = mutation;
      } catch (error) {
        throw new TypeError('Mutation must be a gql-parsed DocumentNode');
      }
    }

    /**
     * Whether the mutation has been called
     */
    called: boolean;

    /**
     * Whether to ignore the results of the mutation.
     */
    ignoreResults = false;

    /**
     * The ID number of the most recent mutation since the element was instantiated.
     */
    mostRecentMutationId = 0;

    /**
     * An object that represents the result of this mutation that
     * will be optimistically stored before the server has actually returned a
     * result.
     *
     * This is most often used for optimistic UI, where we want to be able to see
     * the result of a mutation immediately, and update the UI later if any errors
     * appear.
     */
    optimisticResponse: MutationOptions['optimisticResponse'];

    /**
     * A function which updates the apollo cache when the query responds.
     * This function will be called twice over the lifecycle of a mutation.
     * Once at the very beginning if an optimisticResponse was provided.
     * The writes created from the optimistic data will be rolled back before
     * the second time this function is called which is when the mutation has
     * succesfully resolved. At that point update will be called with the actual
     * mutation result and those writes will not be rolled back.
     *
     * The reason a DataProxy is provided instead of the user calling the methods
     * directly on ApolloClient is that all of the writes are batched together at
     * the end of the update, and it allows for writes generated by optimistic
     * data to be rolled back.
     */
    updater?(...params: Parameters<MutationUpdaterFn<TVariables>>):
      ReturnType<MutationUpdaterFn<TVariables>>;

    /**
     * An object that maps from the name of a variable as used in the mutation GraphQL document to that variable's value.
     */
    variables: TVariables;

    /**
     * Increments and returns the most recent mutation id.
     */
    generateMutationId(): number {
      this.mostRecentMutationId += 1;
      return this.mostRecentMutationId;
    }

    /**
     * Returns true when an ID matches the most recent mutation id.
     */
    isMostRecentMutation(mutationId: number): boolean {
      return this.mostRecentMutationId === mutationId;
    }

    /**
     * This resolves a single mutation according to the options specified and returns a Promise which is either resolved with the resulting data or rejected with an error.
     */
    @bound async mutate(
      params?: Partial<MutationOptions<TVariables>>
    ): Promise<FetchResult<TData>> {
      const mutation = params?.mutation ?? this.mutation;
      const optimisticResponse = params?.optimisticResponse ?? this.optimisticResponse;
      const variables = params?.variables ?? this.variables;
      const update = params?.update ?? this.updater;

      const options = {
        ...params ?? {},
        mutation,
        optimisticResponse,
        variables,
        update,
      };

      const mutationId = this.generateMutationId();

      this.loading = true;
      this.error = undefined;
      this.data = undefined;
      this.called = true;

      return this.client.mutate(options)
        .then((response: FetchResult<TData>) => this.onCompletedMutation(response, mutationId))
        .catch((error: ApolloError) => this.onMutationError(error, mutationId));
    }

    /**
     * Callback for when a mutation is completed.
     */
    @bound onCompletedMutation(
      response: FetchResult<TData>,
      mutationId: number,
    ): FetchResult<TData> {
      const { data } = response;
      if (this.isMostRecentMutation(mutationId) && !this.ignoreResults) {
        this.loading = false;
        this.error = null;
        this.data = data;
      }
      this.onCompleted?.(data);
      return response;
    }

    /**
     * Callback for when a mutation fails.
     */
    @bound onMutationError(error: ApolloError, mutationId: number): never {
      if (this.isMostRecentMutation(mutationId)) {
        this.loading = false;
        this.data = null;
        this.error = error;
      }
      /* istanbul ignore next */
      this.onError?.(error);
      throw error;
    }

    /**
     * Callback for when a mutation is completed.
     */
    onCompleted?(_data: FetchResult<TData>): void

    /**
     * Callback for when an error occurs in mutation.
     */
    onError?(_error: Error): void
  }

  return ApolloMutationElement;
}

/**
 * `ApolloMutationMixin`: class mixin for apollo-mutation elements.
 */
export const ApolloMutationMixin =
  dedupeMixin(ApolloMutationMixinImplementation);
