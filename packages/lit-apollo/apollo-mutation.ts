import { ApolloElement } from './apollo-element';
import { ApolloMutationMixin } from '@apollo-elements/mixins/apollo-mutation-mixin';
import { property } from 'lit-element';
import type { MutationOptions, MutationUpdaterFn } from 'apollo-client';
import type { FetchResult } from 'apollo-link';

/**
 * # ApolloMutation
 *
 * üë©‚ÄçüöÄ A custom element base class to issue mutations via your Apollo cache.
 *
 * ## üë©‚ÄçüöÄ Usage
 *
 * ```js
 * import { client } from './apollo-client';
 * import { ApolloMutation, html } from 'lit-apollo';
 * import mutation from './mutation-element.graphql';
 *
 * class MutationElement extends ApolloMutation {
 *   client = client;
 *   mutation = mutation;
 *
 *   render() {
 *     return html`<input @keyup="${this.onInput}"/>`
 *   }
 *
 *   onInput({ target: { value: input }, key }) {
 *     this.variables = { input };
 *     if (key === 'Enter') return this.mutate();
 *   }
 * };
 *
 * customElements.define('mutation-element', MutationElement)
 * ```
 */
export class ApolloMutation<
  TData,
  TVariables,
> extends ApolloMutationMixin(ApolloElement)<TData, TVariables> {
  /**
   * If the mutation has been called
   */
  @property({ type: Boolean }) called = false;

  /**
   * A function which updates the apollo cache when the query responds.
   * This function will be called twice over the lifecycle of a mutation.
   * Once at the very beginning if an optimisticResponse was provided.
   * The writes created from the optimistic data will be rolled back before
   * the second time this function is called which is when the mutation has
   * succesfully resolved. At that point update will be called with the actual
   * mutation result and those writes will not be rolled back.
   *
   * The reason a DataProxy is provided instead of the user calling the methods
   * directly on ApolloClient is that all of the writes are batched together at
   * the end of the update, and it allows for writes generated by optimistic
   * data to be rolled back.
   */
  updater?(
    ...params: Parameters<MutationUpdaterFn<TVariables>>
  ): ReturnType<MutationUpdaterFn<TVariables>>

  /**
   * This resolves a single mutation according to the options specified and returns
   * a Promise which is either resolved with the resulting data or rejected with an
   * error.
   *
   * NOTE: this `LitElement` version passes `this.updater` as the update function
   * by default, instead of `this.update`, which is provided by `LitElement`.
   *
   */
  async mutate(params?: Partial<MutationOptions<TVariables>>): Promise<FetchResult<TData>> {
    const update =
        (params && 'update' in params) ? params.update
      : this.updater;
    return super.mutate({ update, ...params });
  }
}
